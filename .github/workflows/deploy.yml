name: Deploy ASP.NET Core API to AWS Lambda (API Gateway integration)

on:
  push:
    branches:
      - common-devlopement
  workflow_dispatch:
    inputs:
      environment:
        description: 'Select deployment environment (development, staging, production)'
        required: true
        default: 'development'

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  DOTNET_CLI_TELEMETRY_OPTOUT: '1'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      ENVTYPE: ${{ github.event.inputs.environment || 'development' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Install tools
        run: |
          dotnet tool install -g Amazon.Lambda.Tools --version 6.1.0 || true
          export PATH="$PATH:$HOME/.dotnet/tools"

      - name: Restore
        run: dotnet restore

      - name: Build
        run: dotnet build --configuration Release --no-restore

      - name: Publish
        run: dotnet publish -c Release -r linux-x64 --self-contained false -o publish

      - name: Create deployment zip
        run: |
          rm -f app.zip
          cd publish
          zip -r ../app.zip .
          cd ..

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.AWS_REGION }}" ]; then echo "Missing AWS_REGION"; exit 1; fi
          if [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]; then echo "Missing AWS_ACCESS_KEY_ID"; exit 1; fi
          if [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]; then echo "Missing AWS_SECRET_ACCESS_KEY"; exit 1; fi
          if [ -z "${{ secrets.LAMBDA_FUNCTION_NAME }}" ]; then echo "Missing LAMBDA_FUNCTION_NAME (set repository secret)"; exit 1; fi

      - name: Ensure S3 bucket for artifacts exists (optional)
        env:
          APP_NAME: Sample-AUTH-API
        run: |
          APP_NAME_LC=$(echo "$APP_NAME" | tr '[:upper:]' '[:lower:]')
          BUCKET_NAME="${APP_NAME_LC}-${{ secrets.AWS_ACCOUNT_ID }}"
          echo "Using bucket: $BUCKET_NAME"
          aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null || aws s3 mb "s3://$BUCKET_NAME" --region "${{ secrets.AWS_REGION }}"
          echo "BUCKET_NAME=$BUCKET_NAME" >> $GITHUB_ENV

      - name: Upload artifact to S3 (optional)
        if: env.BUCKET_NAME
        run: |
          VERSION_LABEL="v${GITHUB_RUN_NUMBER}-$(date +%Y%m%d%H%M%S)"
          aws s3 cp app.zip "s3://$BUCKET_NAME/$VERSION_LABEL.zip"
          echo "VERSION_LABEL=$VERSION_LABEL" >> $GITHUB_ENV

      - name: Create or update Lambda function
        env:
          LAMBDA_FUNCTION_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME }}
          LAMBDA_ROLE_ARN: ${{ secrets.LAMBDA_ROLE_ARN }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -e
          echo "Checking Lambda function: $LAMBDA_FUNCTION_NAME"
          if aws lambda get-function --function-name "$LAMBDA_FUNCTION_NAME" >/dev/null 2>&1; then
            echo "Function exists — updating code"
            aws lambda update-function-code --function-name "$LAMBDA_FUNCTION_NAME" --zip-file fileb://app.zip
          else
            echo "Function not found"
            if [ -z "$LAMBDA_ROLE_ARN" ]; then
              echo "LAMBDA_ROLE_ARN not provided. Cannot create function automatically. Create the function and re-run.";
              exit 1
            fi

            echo "Creating Lambda function $LAMBDA_FUNCTION_NAME"
            aws lambda create-function \
              --function-name "$LAMBDA_FUNCTION_NAME" \
              --runtime provided.al2 \
              --role "$LAMBDA_ROLE_ARN" \
              --handler "AuthAPIwithController::AuthAPIwithController.LambdaEntryPoint::FunctionHandlerAsync" \
              --zip-file fileb://app.zip
          fi

      - name: Publish new Lambda version
        env:
          LAMBDA_FUNCTION_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME }}
        run: aws lambda publish-version --function-name "$LAMBDA_FUNCTION_NAME" || true

      - name: Create/update API Gateway HTTP API
        env:
          LAMBDA_FUNCTION_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          ENVTYPE: ${{ env.ENVTYPE }}
        run: |
          set -e
          FUNCTION_ARN=$(aws lambda get-function --function-name "$LAMBDA_FUNCTION_NAME" --query 'Configuration.FunctionArn' --output text)
          echo "Function ARN: $FUNCTION_ARN"
          API_NAME="${LAMBDA_FUNCTION_NAME}-http-api-${ENVTYPE}"
          EXISTING_API_ID=$(aws apigatewayv2 get-apis --query "Items[?Name=='$API_NAME'].ApiId | [0]" --output text || echo "")

          if [ -z "$EXISTING_API_ID" ] || [ "$EXISTING_API_ID" = "None" ]; then
            echo "Creating HTTP API $API_NAME"
            API_ID=$(aws apigatewayv2 create-api --name "$API_NAME" --protocol-type HTTP --target "$FUNCTION_ARN" --query 'ApiId' --output text)
            aws lambda add-permission --function-name "$LAMBDA_FUNCTION_NAME" --statement-id apigw-invoke-$API_ID --action lambda:InvokeFunction --principal apigateway.amazonaws.com --source-arn "arn:aws:execute-api:${AWS_REGION}:*:$API_ID/*/*/*" || true
            ENDPOINT=$(aws apigatewayv2 get-apis --query "Items[?ApiId=='$API_ID'].ApiEndpoint" --output text)
            echo "API endpoint (${ENVTYPE}): $ENDPOINT"
            echo "API_ENDPOINT=$ENDPOINT" >> $GITHUB_ENV
          else
            echo "Found API $API_NAME with id $EXISTING_API_ID — creating new integration to latest function"
            INTEGRATION_URI="arn:aws:apigateway:${AWS_REGION}:lambda:path/2015-03-31/functions/$FUNCTION_ARN/invocations"
            INTEGRATION_ID=$(aws apigatewayv2 create-integration --api-id "$EXISTING_API_ID" --integration-type AWS_PROXY --integration-uri "$INTEGRATION_URI" --payload-format-version "2.0" --query 'IntegrationId' --output text)
            ROUTE_EXISTS=$(aws apigatewayv2 get-routes --api-id "$EXISTING_API_ID" --query 'Items[].RouteKey' --output text | grep '\$default' || true)
            if [ -z "$ROUTE_EXISTS" ]; then
              aws apigatewayv2 create-route --api-id "$EXISTING_API_ID" --route-key '$default' --target "integrations/$INTEGRATION_ID" || true
            else
              aws apigatewayv2 create-route --api-id "$EXISTING_API_ID" --route-key '$default' --target "integrations/$INTEGRATION_ID" || true
            fi
            ENDPOINT=$(aws apigatewayv2 get-apis --query "Items[?ApiId=='$EXISTING_API_ID'].ApiEndpoint" --output text)
            echo "API endpoint (${ENVTYPE}): $ENDPOINT"
            echo "API_ENDPOINT=$ENDPOINT" >> $GITHUB_ENV
          fi

      - name: Ensure CloudWatch logs exist for Lambda (diagnostic)
        env:
          LAMBDA_FUNCTION_NAME: ${{ secrets.LAMBDA_FUNCTION_NAME }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          echo "Listing CloudWatch log groups for /aws/lambda/$LAMBDA_FUNCTION_NAME"
          aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/$LAMBDA_FUNCTION_NAME" --region "$AWS_REGION" || true

      - name: Cleanup
        run: rm -f app.zip || true

      - name: Done
        run: |
          echo "Deployment finished. API endpoint: ${{ env.API_ENDPOINT }}"
